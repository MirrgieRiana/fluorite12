このドキュメント内では、結合優先度の高い演算子から順に記載されています。

# 因子

因子は単独で機能するリテラルや括弧類を指します。

因子は演算子の結合において、原子的な性質を持ちます。

## 識別子 `identifier`

識別子は組み込み定数や変数、引数などを指し表す文字列です。

```shell
$ flc 'TRUE'
# TRUE

$ flc 'x := 10; y := 2; x + y'
# 12

$ flc '(x, y -> x + y)(10; 2)'
# 12
```

---

識別子は1文字以上の英数字もしくはアンダースコア `_` であり、かつ先頭は数字であってはいけません。

`[A-Za-z_][A-Za-z_0-9]*`

## 整数リテラル `123`

1個以上の数字の列は整数リテラルになります。

```shell
$ flc '123'
# 123
```

---

0で始まる数字列であっても常に10進数として解釈されます。

```shell
$ flc '00123'
# 123
```

## 16進整数リテラル `H#123abc`

`H#` に続いて16進数を書くことができます。

`H#` の部分は大文字でなければなりませんが、16進数の部分は大文字小文字を区別しません。

```shell
$ flc 'H#FF'
# 255
```

## 浮動小数点数リテラル `1.23`

実数を「整数部 `.` 小数部」の形で書くことができます。

実数値の表現や演算には計算誤差が含まれます。

```shell
$ flc '1.5'
# 1.5
```

## 生文字列リテラル `'contents'`

生文字列リテラルは `'` `'` で囲まれた文字列であり、ほとんどの文字をそのまま解釈します。

| 文字列     | 意味      |
|---------|---------|
| `''`    | `'`     |
| CRLF    | LF      |
| CR      | LF      |
| LF      | LF      |
| `'`     | 生文字列の終端 |
| それ以外の文字 | その文字自身  |

### シングルクォートコンテント `''`

生文字列内で `'` を記述するには `''` と書きます。

```shell
$ flc " 'abc''def' "
# abc'def
```

### 改行コンテント

生文字列内には改行を含めることができますが、すべてLFに統一されます。

この性質は、ソースコードの改行コードが変更されてもプログラムの動作が変わらないことを保証します。

```shell
$ flc " 'abc
def' "
# abc
# def
```

### 文字コンテント `abcABC123`

上記を除く文字は書いたとおりに解釈されます。

これは `$` や ` \ ` も例外ではありません。

```shell
$ flc \''abc$def\nop'\'
# abc$def\nop
```

## テンプレート文字列リテラル `"contents"`

テンプレート文字列リテラルは `"` `"` で囲まれた文字列であり、エスケープや埋め込みなどの機能が使えます。

| 文字列                   | 意味           |
|-----------------------|--------------|
| `\"`                  | `"`          |
| `\$`                  | `$`          |
| ` \\ `                | ` \ `        |
| `\t`                  | タブ文字         |
| `\r`                  | CR           |
| `\n`                  | LF           |
| 上記以外の ` \ ` で始まるシーケンス | 構文エラー        |
| CRLF                  | LF           |
| CR                    | LF           |
| LF                    | LF           |
| `$` 識別子や括弧類など         | 埋め込み         |
| `$%` フォーマット指定子 括弧類    | フォーマット付き埋め込み |
| `"`                   | テンプレート文字列の終端 |
| それ以外の文字               | その文字自身       |

### エスケープシーケンスコンテント `\n`

エスケープシーケンスコンテントは ` \ ` で始まる一連のシーケンスであり、それぞれ決められた文字を表します。

エスケープシーケンスの一覧は上記の表を参照してください。

` \ ` で始まるシーケンスは将来の機能のために予約されており、不正なシーケンスは構文エラーとなります。

```shell
$ flc ' "abc\"def\\ghi\njkl" '
# abc"def\ghi
# jkl
```

### 改行コンテント

生文字列リテラルの改行コンテントと同様です。

### 埋め込みコンテント `$factor`

`$` に続いて任意の識別子、リテラル、括弧類を記述でき、その値は文字列化されたうえで文字列に埋め込まれます。

最も一般的な利用形態は、丸括弧によって任意の式を埋め込むことや、単一の識別子を埋め込むことです。

```shell
$ flc ' "value is $(100 + 20 + 3)" '
# value is 123

$ flc '
  value := 123
  "value is $value"
'
# value is 123
```

### フォーマット付き埋め込みコンテント `$%-+ 07.2f(value)`

フォーマット付き埋め込みコンテントは通常の埋め込みコンテントに似ていますが、以下の点で異なります。

- `$` に続いて、 `%` から始まるフォーマット指定子を記述します。
- 識別子などを直接埋め込むことはできず、括弧類に限られます。

```shell
$ flc ' "[$%+09.2f(123)]" '
# [+00123.00]
```

---

フォーマット指定子の文法は以下の通りです。

1. `%`
    - 必須のマジックワードです。
2. フラグ（省略可能）
    - 下表のフラグを0個以上指定することができます。
3. 幅（省略可能）
    - 文字列の長さが幅未満である場合に半角空白で補充します。
4. `.` 精度（省略可能）
    - 表示する小数の桁数を指定します。
5. 変換
    - 下表の変換を指定します。

| フラグ  | 意味                   |
|------|----------------------|
| `-`  | 左揃えにします。             |
| `+`  | 符号を常に表示します。          |
| 半角空白 | 符号のための半角空白を表示します。    |
| `0`  | スペースの代わりに `0` で埋めます。 |

| 変換 | 意味    |
|----|-------|
| d  | 10進整数 |
| x  | 16進整数 |
| f  | 10進小数 |
| s  | 文字列   |

### 文字コンテント `abcABC123`

上記を除く文字は書いたとおりに解釈されます。

## 埋め込み文字列リテラル `%>contents<%`

埋め込み文字列リテラルは `%>` `<%` で囲われた独特な見た目の文字列リテラルです。

| 文字列          | 意味         |
|--------------|------------|
| `<%%`        | `<%`       |
| CRLF         | LF         |
| CR           | LF         |
| LF           | LF         |
| `<%=` 式 `%>` | 埋め込み       |
| `<%`         | 埋め込み文字列の終端 |
| それ以外の文字      | その文字自身     |

---

埋め込み文字列リテラルは、特にHTMLコードの生成と相性がよいです。

```shell
$ flc '
  %>
    <table>
      <tr style="color: red;"><th>x</th><th>x×10</th></tr>
      <%= 1 .. 3 | x => %>
        <tr><td><%= x %></td><td><%= x * 10 %></td></tr>
      <% %>
    </table>
  <%
'
#
#    <table>
#      <tr style="color: red;"><th>x</th><th>x×10</th></tr>
#
#        <tr><td>1</td><td>10</td></tr>
#
#        <tr><td>2</td><td>20</td></tr>
#
#        <tr><td>3</td><td>30</td></tr>
#
#    </table>
#
```

<table>
  <tr style="color: red;"><th>x</th><th>x×10</th></tr>
  <tr><td>1</td><td>10</td></tr>
  <tr><td>2</td><td>20</td></tr>
  <tr><td>3</td><td>30</td></tr>
</table>

### 埋め込み文字列終了シーケンスコンテント `<%%`

埋め込み文字列内で `<%` を記述するには `<%%` と書きます。

```shell
$ flc '%>[ <%% ]<%'
#[ <% ]
```

### 改行コンテント

生文字列リテラルの改行コンテントと同様です。

### 埋め込みコンテント `<%= value %>`

`<%=` `%>` で囲うと任意の値を文字列化したうえで埋め込むことができます。

丸括弧と同様、内部で宣言された変数が外部に出ない効果があります。

```shell
$ flc ' %>value is <%= 100 + 20 + 3 %><% '
# value is 123
```

### 文字コンテント `abcABC123`

上記を除く文字は書いたとおりに解釈されます。

## 括弧 `(value)`

括弧 `(` `)` は任意の式を内部に含めることができる、何も行わない因子です。

括弧は計算順序の変更などに使うことができます。

```shell
$ flc '(1 + 2) * 10'
# 30
```

---

括弧内には、実際には複文を書くことができます。

以下のサンプルコードでは、変数 `a` を0で初期化して、括弧内で `a` に100を代入し、括弧自体は `a + 20` である120を返します。括弧の値は3と和を取られ、結果、プログラムの出力は123になります。

fluorite12では、多くのプログラミング言語とは異なり、複文に `{` `}` を使うことはできません。

```shell
$ flc '
  a := 0
  (
    a = 100
    a + 20
  ) + 3
'
# 123
```

---

括弧の内側で宣言された変数は、括弧外に影響を及ぼしません。

```shell
$ flc '
  a := 10
  (
    a := 20
    OUT(a)
    a = 30
    OUT(a)
  )
  a
'
# 20
# 30
# 10
```

## 配列リテラル `[value; ...]`

`[` `]` は配列を作るリテラルです。

括弧内には、 `;` で区切って0個以上の値を書くことができます。

```shell
$ flc '[1; 2; 3]'
# [1;2;3]
```

---

`;` で区切られた項がストリームである場合、ストリームそのものではなくストリームの各要素が配列に格納されます。

```shell
$ flc '[1 .. 3 | _ * 10; 4 .. 6 | _ * 100]'
# [10;20;30;400;500;600]
```

---

配列リテラル内での `;` の記述は柔軟です。

項の前後や中間に `;` を余計に多く書いても問題ありません。

また、改行は `;` の代わりになります。

```shell
$ flc '[
  10
  20
  ; ; ; 30; ; ;
]'
# [10;20;30]
```

## オブジェクトリテラル `{entry; ...}`

`{` `}` はオブジェクトを作るリテラルです。

括弧内には、 `;` で区切って0個以上のエントリーを書くことができます。

`{` `}` は文レベルの場所に書かれても、コードブロックではなくオブジェクトリテラルとして振舞います。

```shell
$ flc '{a: 1; b: 2}'
# {a:1;b:2}
```

---

`;` で区切られた項が `key: value` の形式であることは強制ではなく、実際には2要素の配列、およびそのストリームを受け付けます。

エントリー演算子 `:` は、オブジェクトリテラルとは本質的に無関係な、両辺を2要素の配列にする演算子です。

```shell
$ flc '{1 .. 3 | "Item$_": _ * 10; 4 .. 6 | ["Item$_", _ * 100]}'
# {Item1:10;Item2:20;Item3:30;Item4:400;Item5:500;Item6:600}
```

---

オブジェクトリテラル内での `;` の記述は柔軟です。

項の前後や中間に `;` を余計に多く書いても問題ありません。

また、改行は `;` の代わりになります。

```shell
$ flc '{
  a: 1
  b: 2
  ; ; ; c: 3; ; ;
}'
# {a:1;b:2;c:3}
```

# 後置演算子

後置演算子は基部の後ろに付与する演算子です。

後置演算子は単項のものと二項のものに分かれ、いずれも左優先結合です。

## 前置単項演算子の後置表現 `value.+` ...

すべての前置単項演算子は、 `.` に続けて書く後置演算子のバリエーションが存在します。

以下の組はすべて同じ働きをします。

```
 +A  A.+
 -A  A.-
 ?A  A.?
!!A  A.!!
 !A  A.!
 &A  A.&
$#A  A.$#
$&A  A.$&
$*A  A.$*
```

後置表現を使うと、一部の構文において丸括弧を削減し、可読性を向上できる場合があります。

## 関数呼び出し `function(argument; ...)`

後置丸括弧 `(` `)` により関数を呼び出すことができます。

引数は `;` で区切ります。

```shell
$ flc 'JOIN("-"; 1, 2, 3)'
# 1-2-3
```

---

関数呼び出しにおいて、カンマ `,` は引数の区切りではなく、ストリーム結合演算子であることに注意してください。

## メソッド呼び出し `value::method(argument; ...)`

メソッド呼び出しは、値の親オブジェクトに登録された関数を、その値とともに呼び出します。

```shell
$ flc '"value"::TO_JSON()'
# "value"
```

---

メソッドの本体である関数は、第1引数にメソッドを呼び出した値を、第2引数以降にメソッド呼び出しの引数列を受け取ります。

この例では、クラス用のオブジェクト `Adder` を定義し、そのインスタンスとなる子オブジェクト `adder` を生成し、 `adder` に対してメソッド `add` を呼び出しています。

メソッド `add` の本体となる関数は 、呼び出し元である `adder` の親オブジェクトである `Adder` から検索されます。

```shell
$ flc '
  Adder := {
    add: this, y, z -> this.x + y + z
  }
  adder := Adder{x: 100}
  adder::add(20; 3)
'
# 123
```

## 配列のストリーム化 `array[]`

配列の各要素を順番にイテレートするストリームを返します。

```shell
$ flc '[1, 2, 3][]'
# 1
# 2
# 3
```

---

以下は、配列を、各要素を10倍した配列にする例です。

```shell
$ flc '[1, 2, 3][] | _ * 10 >> ARRAY'
# [10;20;30]
```

## オブジェクトのストリーム化 `object[]`

配列のストリーム化と似ていますが、こちらは各エントリーのキーと値で構成される配列のストリームを返します。

```shell
$ flc '{a: 1; b: 2; c: 3}[]'
# [a;1]
# [b;2]
# [c;3]
```

---

以下は、オブジェクトを、各キーの末尾に `z` を付け、各値を10倍したオブジェクトにする例です。

```shell
$ flc '{a: 1; b: 2; c: 3}[] | _.0 & "z": _.1 * 10 >> OBJECT'
# {az:10;bz:20;cz:30}
```

## 関数の部分適用 `function[argument; ...]`

関数の部分適用は、関数を実行せずに、引数の適用を部分的に予約した関数を生成します。

元の関数は、部分適用された関数の呼び出し時に、部分適用時に与えられた引数列の後に部分適用された関数の呼び出し時の引数列を受け取ります。

```shell
$ flc 'JOIN("-"; 1, 2, 3)'
# 1-2-3

$ flc 'JOIN["-"](1, 2, 3)'
# 1-2-3

$ flc 'JOIN["-"; 1, 2, 3]()'
# 1-2-3

$ flc 'JOIN["-"][1, 2, 3]()'
# 1-2-3
```

---

この文法は、しばしばストリームを操作する関数の扱いに役立ちます。

```shell
$ flc '1, 2, 3 >> JOIN["-"]'
# 1-2-3
```

## メソッドの部分適用 `value::method[argument; ...]`

関数と同様に、メソッド呼び出しにも部分適用ができます。

```shell
$ flc '
  Adder := {
    add: this, y, z -> this.x + y + z
  }
  adder := Adder{x: 100}
  adder::add[20](3)
'
# 123
```

## オブジェクトの継承 `parent{entry; ...}`

オブジェクトに `{` `}` を後置すると、そのオブジェクトを親とする子オブジェクトを生成します。

オブジェクトの継承は主にメソッドの検索に使われ、エントリーの継承は行われません。

オブジェクトの生成方法はオブジェクトリテラルと共通です。

```shell
$ flc '{a: 1; m: this -> 3}{b: 2}'
# {b:2}

$ flc '{a: 1; m: this -> 3}{b: 2}.a'
# NULL

$ flc '{a: 1; m: this -> 3}{b: 2}::m()'
# 3
```

## オブジェクトの要素アクセス `object.key`

`.` 演算子でオブジェクトの要素にアクセスできます。

```shell
$ flc '{x: 123}.x'
# 123
```

---

オブジェクトが親オブジェクトを持つ場合でも、親オブジェクトの要素は継承されません。

```shell
$ flc '{x: 123}{}.x'
# NULL
```

---

`.` の右辺に括弧を置くことで、任意の式によって参照できます。

```shell
$ flc '
  obj := {item1: 123; item2: 456}
  index := 2
  obj.("item$index")
'
# 456
```

---

`.` は、右辺が識別子の場合、それを変数ではなくキーとして解釈する性質があります。

したがって、括弧の有無によって参照するエントリーに違いが現れます。

```shell
$ flc '
  key := "item1"
  obj := {key: 123; item1: 456}
  [obj.key; obj.(key)]
'
# [123;456]
```

## 配列の要素アクセス `array.index`

`.` 演算子で配列の要素にアクセスできます。

```shell
$ flc '[10, 20, 30].1'
# 20
```

---

オブジェクトの要素アクセスと同様に、 `.` の右辺を式にすることができます。

```shell
$ flc '[10, 20, 30].(1 + 1)'
# 30
```

# 前置演算子

前置演算子は基部の前に付与する演算子です。

前置演算子は右優先結合です。

## 数値化 `+value`

前置 `+` 演算子は値の数値化を行います。

| 値のタイプ | 数値化の結果           |
|-------|------------------|
| NULL  | 0                |
| 数値    | その数値自身           |
| 論理値   | TRUEなら1、FALSEなら0 |
| 文字列   | 数値としてパースした結果     |
| ストリーム | 各要素の合計           |

主な用途は、文字列として表現されている数値データを内部的な数値に変換することです。

```shell
$ flc ' "+123"'
# +123

$ flc '+"+123"'
# 123
```

## 負の数値化 `-value`

前置 `-` 演算子は数値化演算子と似ていますが、その値を負にします。

この演算子は「任意の値を数値に変換する処理」と「数値を負にする処理」を同時に行います。

```shell
$ flc '-"123"'
# -123

$ flc '-(100 + 20 + 3)'
# -123
```

## 論理値化 `?value`

前置 `?` 演算子は値の論理値化を行います。

```shell
$ flc '?1'
# TRUE

$ flc '?0'
# FALSE
```

---

値のタイプによってどのように論理値化が行われるかが異なります。

| タイプ   | 動作             |
|-------|----------------|
| NULL  | 常に偽            |
| 数値    | 0でない場合に真       |
| 論理値   | それ自身を返す        |
| 文字列   | 空文字列でない場合に真    |
| ストリーム | いずれかの要素が真の場合に真 |

## 否定論理値化 `!value`

前置 `!` 演算子は論理値化演算子と似ていますが、否定の値を得ます。

```shell
$ flc '!TRUE'
# FALSE

$ flc '!FALSE'
# TRUE
```

## 文字列化 `&value`

前置 `&` 演算子は、値の文字列表現を得るのに使います。

```shell
$ flc '&[1..3]'
# [1;2;3]
```

---

値の種類ごとの文字列表現は以下の通りです。

- NULLは `NULL` になります。
- 整数値の文字列表現は、その整数値の10進数表現になります。
- TRUEは `TRUE` 、FALSEは `FALSE` になります。
- 文字列の文字列表現は、その文字列自身です。
- 配列の文字列表現は、 `[1;2;3]` のように、 `;` で区切って `[` `]` で囲んだものです。
- オブジェクトの文字列表現は、 `{a:1;b:2}` のように、キーと値を `:` で区切り、そのエントリーを `;` で区切り、全体を `{` `}` で囲んだものです。

---

文字列化の実態は、値のTO_STRINGメソッドを呼び出すことで行われます。

オブジェクトのTO_STRINGメソッドをオーバーライドすることで、文字列化の処理を変更することができます。

```shell
$ flc '&{TO_STRING: this -> "The value is $(this.value)"}{value: 100}'
# The value is 100
```

## 長さの取得 `$#value`

前置 `$#` 演算子は、値の「長さ」を取得します。

```shell
$ flc '$#"123"'
# 3

$ flc '$#[1, 2, 3]'
# 3

$ flc '$#{a: 1; b: 2; c: 3}'
# 3
```

---

この演算子は値のタイプによって異なるものを返します。

| タイプ    |                     |
|--------|---------------------|
| 文字列    | UTF16による文字の長さ       |
| 配列     | 要素数                 |
| オブジェクト | 親オブジェクトを無視した、エントリの数 |

## スロー `!!error`

fluorite12では、例外のスローを前置 `!!` 演算子で行います。

スローする値はどのようなタイプの値であっても構いません。

スローした値は、キャッチした際に渡されます。

```shell
$ flc '!!"12345" !? e => "Error ($e)"'
# Error (12345)
```

# べき乗系演算子

べき乗系演算子は、べき乗演算子のみで構成されます。

べき乗系演算子は右優先結合です。

## べき乗 `number ^ number`

べき乗演算子は、左辺の値を右辺の値で累乗します。

整数の整数乗の結果も浮動小数点数で返されます。

```shell
$ flc '2 ^ 3'
# 8
````

# 乗除算系演算子

乗除算系演算子は、乗除算に類する動作を行う演算子で構成されます。

乗除算系演算子は左優先結合です。

## 乗算 `number * number`

乗算演算子は、2つの値を乗算します。

```shell
$ flc '2 * 3'
# 6
```

---

文字列の乗算はその文字列を繰り返します。

```shell
$ flc '"abc" * 3'
# abcabcabc
```

---

配列の乗算はその配列を繰り返します。

```shell
$ flc '[1, 2, 3] * 3'
# [1;2;3;1;2;3;1;2;3]
```

## 除算 `number / number`

除算演算子は、2つの値を除算します。

```shell
$ flc '6 / 3'
# 2
```

---

整数同士の除算でも、結果は浮動小数点数で返されます。

```shell
$ flc '7 / 4'
# 1.75
```

## 剰余 `number % number`

剰余演算子は、2つの値を除算し、その余りを返します。

```shell
$ flc '7 % 4'
# 3
```

## 整除性 `integer %% integer`

左辺の値が右辺の値で割り切れるかどうかを返します。

```shell
$ flc '7 %% 4'
# FALSE
```

# 加減算系演算子

加減算系演算子は、加減算に類する動作を行う演算子で構成されます。

加減算系演算子は左優先結合です。

## 加算 `number + number`

加算演算子は、2つの値を加算します。

```shell
$ flc '1 + 2'
# 3
```

## 減算 `number - number`

減算演算子は、2つの値を減算します。

```shell
$ flc '3 - 1'
# 2
```

## 文字列の結合 `string & string`

文字列の連結を行うには `&` 演算子を使います。

```shell
$ flc '"abc" & "def"'
# abcdef
```

# 代入系演算子

代入系演算子は、代入文やラムダ式など、値を割り当てる動作を行う演算子で構成されます。

代入系演算子は右優先結合です。

## 変数の宣言 `variable := value`

変数宣言演算子は、書かれたスコープ内で変数を宣言しつつ、右辺の値で初期化します。

fluorite12では、変数は宣言されると同時に初期化される必要があります。

```shell
$ flc '
  a := 123
  OUT(a)
  ; ,
'
# 123
```

---

宣言された変数は、そのスコープ内でのみ有効です。

`(` `)` など、スコープを生成する演算子内で宣言された変数は、そのスコープを抜けると破棄されます。

```shell
$ flc '
  a := 10
  OUT(a)
  (
    a := 20
    OUT(a)
    a = 30
    OUT(a)
  )
  OUT(a)
  ; ,
'
# 10
# 20
# 30
# 10
```

## 代入 `variable = value`

代入演算子は、左辺の変数に右辺の値を代入します。

代入先の変数はすでに宣言されている必要があります。

```shell
$ flc '
  a := 123
  OUT(a)
  a = 456
  OUT(a)
  ; ,
'
# 123
# 456
```

## ラムダ演算子 `arguments -> formula`

ラムダ演算子は関数オブジェクトを作る演算子です。

`->` の左辺に引数名を、右辺に戻り値である式を記述します。

```shell
$ flc '
  func := x, y -> x * y
  func(3; 4)
'
# 12
```

---

ラムダ式の引数の基本形は `(argument; ...)` のように `;` で区切り、 `(` `)` で囲ったものです。

シンタックスシュガーとして、 `;` の代わりに `,` で区切ることができ、その場合は `(` `)` を省略できます。

その結果、引数列を以下のように書くことができます。

```
(x; y) -> NULL
(x, y) -> NULL
x, y -> NULL

(x) -> NULL
x -> NULL

() -> NULL
```

---

変数 `__` には、与えられた引数列が配列で渡されます。

これにより、ストリームを使う以外の方法で可変長引数を受け取ることができます。

```shell
$ flc '(() -> __)(1; 2; 3; 4; 5)'
# [1;2;3;4;5]
```

引数列では、引数に指定されたストリームを展開せずにそのまま受け取ることができます。

```shell
$ flc '(() -> &[__.1])(1 .. 3; 4 .. 6; 7 .. 9)'
# [4;5;6]
```

---

fluorite12では、引数の個数の異なる関数呼び出しを行うことができます。

引数が足りない場合はNULLが渡され、多すぎる場合は無視されます。

```shell
$ flc '(x, y -> y)(1)'
# NULL
$ flc '(x, y -> y)(1; 2; 3)'
# 2
```

# パイプ系演算子

パイプ系演算子はストリームを加工することに長けた演算子です。

非常に低い結合優先度を持ち、式に制御構文レベルの構造を与えることもできます。

パイプ系演算子は左優先結合です。

## パイプ `stream | formula`

パイプ演算子 `|` は、左辺のストリームの各値に対して右辺を評価し、そのフラットなストリームを返します。

右辺では、変数 `_` によって左辺の各要素の値を得ることができます。

```shell
$ flc '1 .. 3 | _, _ * 10'
# 1
# 10
# 2
# 20
# 3
# 30
```

---

左辺がストリームでない場合、右辺の返却値はストリームで改めてラッピングされることなく、そのままの型で返されます。

```shell
$ flc '(5 | _ * 10) + 7'
# 57
```

---

右辺に渡される変数は `=>` によって変更できます。

```shell
$ flc '5 | x => x * 10'
# 50
```

## フィルターパイプ `stream ?| predicate`

フィルターパイプはパイプと似通っていますが、右辺の真偽値を評価し、真のもののみを返します。

```shell
$ flc '[1 .. 5 ?| _ %% 2]'
# [2;4]
```

## 否定フィルターパイプ `stream !| predicate`

否定フィルターパイプはフィルターパイプの否定バージョンです。

```shell
$ flc '[1 .. 5 !| _ %% 2]'
# [1;3;5]
```

## 右実行パイプ `stream >> function`

右実行パイプは、左辺のストリームを右辺の関数の引数に指定して呼び出します。

```shell
$ flc '1 .. 3 >> JOIN["-"]'
# 1-2-3
```

---

この演算子はストリームを扱う関数の実行に便利です。

```shell
$ flc '"1+2+3" >> SPLIT["+"] | +_ * 2 >> JOIN["-"]'
# 2-4-6
```

## 左実行パイプ `function << stream`

左実行パイプは、右実行パイプの左右が逆のバージョンです。

使い方によっては可読性に貢献する可能性を秘めています。

```shell
$ flc 'OUT << "Hello" << "World"; ,'
# Hello
# World
```

# ルートノード

ルートノードではファイル全体や括弧の直下など、どんな式でも書ける場所のルールを定義します。

## 複文 `runner; ...; getter`

複文は、0個以上の文と複文自体の値となる末尾式を `;` で区切って繋いだものです。

以下のサンプルコードにおいて、最後の `a` の行のみが式（getter）扱いで、その上の3行は文（runner）扱いです。

以下のサンプルコードでは、変数 `a` を宣言しつつ10を代入し、10が格納されている `a` の値を出力、次に `a` に20を代入し、末尾式として20の格納されている `a` を指定しています。

```shell
$ flc '
  a := 10;
  OUT(a);
  a = 20;
  a
'
# 10
# 20
```

---

末尾式は省略することができます。

その場合、文が末尾式でないことを示すために、末尾に `;` が必要となる場合があります。

末尾式が省略された複文の値は常に `NULL` となります。

```shell
$ flc '1 + 2;'
# NULL

$ flc ''
# NULL
```

---

複文内での `;` の記述は、末尾を除いて柔軟です。

項の前や中間に `;` を余計に多く書いても問題ありません。

末尾式の後にはセミコロンを書くことはできません。

また、改行は `;` の代わりになります。

```shell
$ flc '
  a := 10
  OUT(a)
  ; ; ; a = 20; ; ;
  a
'
# 10
# 20
```

# 組み込み定数

組み込み定数は、コード上で定義することなく利用可能な、言語機能に付属する定数です。

組み込み定数は大文字および `_` のみを使って定義されます。

組み込みの関数も組み込み定数と同じメカニズムによって提供されます。

## 組み込みオブジェクトのクラス定数

各種組み込みオブジェクトのクラスを参照できます。

- `VALUE_CLASS`
- `NULL_CLASS`
- `INT_CLASS`
- `DOUBLE_CLASS`
- `BOOLEAN_CLASS`
- `STRING_CLASS`
- `ARRAY_CLASS`
- `OBJECT_CLASS`
- `FUNCTION_CLASS`
- `STREAM_CLASS`

## 定数

各種、特別な値を表す定数です。

| 定数      | 意味      |
|---------|---------|
| `NULL`  | NULL値   |
| `TRUE`  | 真       |
| `FALSE` | 偽       |
| `EMPTY` | 空のストリーム |

---

数学系の組み込み定数です。

| 定数   | 意味    |
|------|-------|
| `PI` | 円周率   |
| `E`  | ネイピア数 |

## 数学系関数

### `SQRT` 平方根の取得

第1引数の正の平方根を返します。

```shell
$ flc 'SQRT(100.0)'
# 10.0
```

## ストリーム系関数

### `JOIN` ストリームを文字列に連結

`JOIN(separator: VALUE; stream: VALUE): STRING`

第2引数のストリームの各要素を第1引数のセパレータで連結した文字列を返します。

```shell
$ flc 'JOIN("|"; "a", "b", "c")'
# a|b|c
```

---

セパレータやストリームの各要素は文字列化されます。

```shell
$ flc 'JOIN(0; 1, "b", {TO_STRING: _ -> "c"}{})'
# 10b0c
```

---

部分適用とともに用いることで、パイプチェーンに組み込みやすくなります。

```shell
$ flc '1 .. 3 | _ * 10 >> JOIN["|"]'
# 10|20|30
```

### `SPLIT` 文字列をストリームに分割

`SPLIT(separator: VALUE; string: VALUE): STREAM<STRING>`

第2引数の文字列を第1引数のセパレータで分割し、各部分をストリームとして返します。

パイプ演算子との親和性のために配列ではなくストリームとして返されることに注意してください。

`SPLIT` は概念的に `JOIN` と逆の操作を行います。

```shell
$ flc 'SPLIT("|"; "a|b|c")'
# a
# b
# c
```

---

セパレータや分割対象文字列は文字列化されて評価されます。

---

部分適用とともに用いることで、パイプチェーンに組み込みやすくなります。

```shell
$ flc '"10|20|30" >> SPLIT["|"] | +_ / 10'
# 1
# 2
# 3
```

### `KEYS` オブジェクトのキーのストリームを取得

`KEYS(object: OBJECT): STREAM<STRING>`

第1引数のオブジェクトのキーのストリームを返します。

```shell
$ flc 'KEYS({a: 1; b: 2; c: 3})'
# a
# b
# c
```

### `VALUES` オブジェクトの値のストリームを取得

`VALUES(object: OBJECT): STREAM<VALUE>`

第1引数のオブジェクトの値のストリームを返します。

```shell
$ flc 'VALUES({a: 1; b: 2; c: 3})'
# 1
# 2
# 3
```

### `SUM` ストリームの要素の合計

`SUM(numbers: STREAM<NUMBER>): NUMBER`

第1引数のストリームの各要素を加算した値を返します。

```shell
$ flc 'SUM(1 .. 3)'
# 6.0
```

# コマンドラインツール

## `flc`

`flc` は第1引数に渡されたfluorite12のコードをその場で実行するコマンドです。

`flc` コマンドはコードの戻り値を自動的に出力するため、結果の出力のために明示的に `OUT` 関数などを使う必要はありません。

```shell
$ flc '1 + 2'
# 3
```

---

コードの値がストリームだった場合、各要素を1行ずつ出力します。

```shell
$ flc '1 .. 3'
# 1
# 2
# 3
```

---

何も出力させたくない場合は、コードの戻り値を空ストリームにします。

```shell
$ flc '1 + 2; ,'
```

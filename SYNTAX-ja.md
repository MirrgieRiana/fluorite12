このドキュメント内では、結合優先度の高い演算子から順に記載されています。

# リテラル

fluorite12において、リテラルは単独で機能する構文や括弧類を指します。

リテラルは演算子の結合において、原子的な性質を持ちます。

## 整数リテラル `123`

1個以上の数字の列は整数リテラルになります。

```shell
$ flc '123'
# 123
```

---

0で始まる数字列であっても常に10進数として解釈されます。

```shell
$ flc '00123'
# 123
```

## 生文字列リテラル `'abc''def'`

生文字列リテラルは `'` `'` で囲まれた文字列です。

生文字列リテラル内では、改行と `'` 以外のすべての文字が現れたまま解釈されます。

`'` を入力するには、 `''` と書きます。

```shell
$ flc " 'abc''def' "
# abc'def

$ flc " 'abc
def' "
# abc
# def
```

---

以下は生文字列リテラル内での各文字の働きです。

改行文字は、CRやCRLFもLFとして解釈されることに注意してください。

| 文字      | 意味      |
|---------|---------|
| `''`    | `'`     |
| 改行文字    | LF      |
| `'`     | 生文字列の終端 |
| それ以外の文字 | その文字自身  |

## 括弧 `(value)`

括弧 `(` `)` は任意の式を内部に含めることができる、何も行わないリテラルです。

括弧は計算順序の変更などに使うことができます。

```shell
$ flc '(1 + 2) * 10'
# 30
```

---

括弧内には、実際には複文を書くことができます。

以下のサンプルコードでは、変数 `a` を0で初期化して、括弧内で `a` に100を代入し、括弧自体は `a + 20` である120を返します。括弧の値は3と和を取られ、結果、プログラムの出力は123になります。

```shell
$ flc '
  a := 0
  (
    a = 100
    a + 20
  ) + 3
'
# 123
```

---

括弧の内側で宣言された変数は、括弧外に影響を及ぼしません。

```shell
$ flc '
  a := 10
  (
    a := 20
    OUT(a)
  )
  a
'
# 20
# 10
```

## 配列リテラル `[value; ...]`

`[` `]` は配列を作るリテラルです。

括弧内には、 `;` で区切って0個以上の値を書くことができます。

```shell
$ flc '[1; 2; 3]'
# [1;2;3]
```

---

`;` で区切られた項がストリームである場合、ストリームそのものではなくストリームの各要素が配列に格納されます。

```shell
$ flc '[1 .. 3 | _ * 10; 4 .. 6 | _ * 100]'
# [10;20;30;400;500;600]
```

---

配列リテラル内での `;` の記述は柔軟です。

項の前後や中間に `;` を余計に多く書いても問題ありません。

また、改行は `;` の代わりになります。

```shell
$ flc '[
  10
  20
  ; ; ; 30; ; ;
]'
# [10;20;30]
```

## オブジェクトリテラル `{entry; ...}`

`{` `}` はオブジェクトを作るリテラルです。

括弧内には、 `;` で区切って0個以上のエントリーを書くことができます。

```shell
$ flc '{a: 1; b: 2}'
# {a:1;b:2}
```

---

`;` で区切られた項が `key: value` の形式であることは強制ではなく、実際には2要素の配列、およびそのストリームを受け付けます。

エントリー演算子 `:` は、オブジェクトリテラルとは本質的に無関係な、両辺を2要素の配列にする演算子です。

```shell
$ flc '{1 .. 3 | "Item$_": _ * 10; 4 .. 6 | ["Item$_", _ * 100]}'
# {Item1:10;Item2:20;Item3:30;Item4:400;Item5:500;Item6:600}
```

---

オブジェクトリテラル内での `;` の記述は柔軟です。

項の前後や中間に `;` を余計に多く書いても問題ありません。

また、改行は `;` の代わりになります。

```shell
$ flc '{
  a: 1
  b: 2
  ; ; ; c: 3; ; ;
}'
# {a:1;b:2;c:3}
```

# 後置演算子

後置演算子は基部の後ろに付与する演算子です。

後置演算子は単項のものと二項のものに分かれ、いずれも左優先結合です。

## 前置単項演算子の後置表現 `value.+` ...

すべての前置単項演算子は、 `.` に続けて書く後置演算子のバリエーションが存在します。

以下の組はすべて同じ働きをします。

```
 +A  A.+
 -A  A.-
 ?A  A.?
!!A  A.!!
 !A  A.!
 &A  A.&
$#A  A.$#
$&A  A.$&
$*A  A.$*
```

後置表現を使うと、一部の構文において丸括弧を削減し、可読性を向上できる場合があります。

## 関数呼び出し `function(argument; ...)`

後置丸括弧 `(` `)` により関数を呼び出すことができます。

引数は `;` で区切ります。

```shell
$ flc 'JOIN("-"; 1, 2, 3)'
# 1-2-3
```

---

関数呼び出しにおいて、カンマ `,` は引数の区切りではなく、ストリーム結合演算子であることに注意してください。

## メソッド呼び出し `value::method(argument; ...)`

メソッド呼び出しは、値の親オブジェクトに登録された関数を、その値とともに呼び出します。

```shell
$ flc '"value"::TO_JSON()'
# "value"
```

---

メソッドの本体である関数は、第1引数にメソッドを呼び出した値を、第2引数以降にメソッド呼び出しの引数列を受け取ります。

この例では、クラス用のオブジェクト `Adder` を定義し、そのインスタンスとなる子オブジェクト `adder` を生成し、 `adder` に対してメソッド `add` を呼び出しています。

メソッド `add` の本体となる関数は 、呼び出し元である `adder` の親オブジェクトである `Adder` から検索されます。

```shell
$ flc '
  Adder := {
    add: this, y, z -> this.x + y + z
  }
  adder := Adder{x: 100}
  adder::add(20; 3)
'
# 123
```

## 関数の部分適用 `function[argument; ...]`

関数の部分適用は、関数を実行せずに、引数の適用を部分的に予約した関数を生成します。

元の関数は、部分適用された関数の呼び出し時に、部分適用時に与えられた引数列の後に部分適用された関数の呼び出し時の引数列を受け取ります。

```shell
$ flc 'JOIN("-"; 1, 2, 3)'
# 1-2-3

$ flc 'JOIN["-"](1, 2, 3)'
# 1-2-3

$ flc 'JOIN["-"; 1, 2, 3]()'
# 1-2-3

$ flc 'JOIN["-"][1, 2, 3]()'
# 1-2-3
```

---

この文法は、しばしばストリームを操作する関数の扱いに役立ちます。

```shell
$ flc '1, 2, 3 >> JOIN["-"]'
# 1-2-3
```

## メソッドの部分適用 `value::method[argument; ...]`

関数と同様に、メソッド呼び出しにも部分適用ができます。

```shell
$ flc '
  Adder := {
    add: this, y, z -> this.x + y + z
  }
  adder := Adder{x: 100}
  adder::add[20](3)
'
# 123
```

## オブジェクトの継承 `parent{entry; ...}`

オブジェクトに `{` `}` を後置すると、そのオブジェクトを親とする子オブジェクトを生成します。

オブジェクトの継承は主にメソッドの検索に使われ、エントリーの継承は行われません。

オブジェクトの生成方法はオブジェクトリテラルと共通です。

```shell
$ flc '{a: 1; m: this -> 3}{b: 2}'
# {b:2}

$ flc '{a: 1; m: this -> 3}{b: 2}.a'
# NULL

$ flc '{a: 1; m: this -> 3}{b: 2}::m()'
# 3
```

# 前置演算子

前置演算子は基部の前に付与する演算子です。

前置演算子は右優先結合です。

## 文字列化 `&value`

前置 `&` 演算子は、値の文字列表現を得るのに使います。

```shell
$ flc '&[1..3]'
# [1;2;3]
```

---

値の種類ごとの文字列表現は以下の通りです。

- NULLは `NULL` になります。
- 整数値の文字列表現は、その整数値の10進数表現になります。
- TRUEは `TRUE` 、FALSEは `FALSE` になります。
- 文字列の文字列表現は、その文字列自身です。
- 配列の文字列表現は、 `[1;2;3]` のように、 `;` で区切って `[` `]` で囲んだものです。
- オブジェクトの文字列表現は、 `{a:1;b:2}` のように、キーと値を `:` で区切り、そのエントリーを `;` で区切り、全体を `{` `}` で囲んだものです。

---

文字列化の実態は、値のTO_STRINGメソッドを呼び出すことで行われます。

オブジェクトのTO_STRINGメソッドをオーバーライドすることで、文字列化の処理を変更することができます。

```shell
$ flc '&{TO_STRING: this -> "The value is $(this.value)"}{value: 100}'
# The value is 100
```

# パイプ系演算子

パイプ系演算子はストリームを加工することに長けた演算子です。

非常に低い結合優先度を持ち、式に制御構文レベルの構造を与えることもできます。

パイプ系演算子は左優先結合です。

## パイプ `stream | formula`

パイプ演算子 `|` は、左辺のストリームの各値に対して右辺を評価し、そのフラットなストリームを返します。

右辺では、変数 `_` によって左辺の各要素の値を得ることができます。

```shell
$ flc '1 .. 3 | _, _ * 10'
# 1
# 10
# 2
# 20
# 3
# 30
```

---

左辺がストリームでない場合、右辺の返却値はストリームで改めてラッピングされることなく、そのままの型で返されます。

```shell
$ flc '(5 | _ * 10) + 7'
# 57
```

---

右辺に渡される変数は `=>` によって変更できます。

```shell
$ flc '5 | x => x * 10'
# 50
```

## フィルターパイプ `stream ?| predicate`

フィルターパイプはパイプと似通っていますが、右辺の真偽値を評価し、真のもののみを返します。

```shell
$ flc '[1 .. 5 ?| _ %% 2]'
# [2;4]
```

## 否定フィルターパイプ `stream !| predicate`

否定フィルターパイプはフィルターパイプの否定バージョンです。

```shell
$ flc '[1 .. 5 !| _ %% 2]'
# [1;3;5]
```

## 右実行パイプ `stream >> function`

右実行パイプは、左辺のストリームを右辺の関数の引数に指定して呼び出します。

```shell
$ flc '1 .. 3 >> JOIN["-"]'
# 1-2-3
```

---

この演算子はストリームを扱う関数の実行に便利です。

```shell
$ flc '"1+2+3" >> SPLIT["+"] | +_ * 2 >> JOIN["-"]'
# 2-4-6
```

## 左実行パイプ `function << stream`

左実行パイプは、右実行パイプの左右が逆のバージョンです。

使い方によっては可読性に貢献する可能性を秘めています。

```shell
$ flc 'OUT << "Hello" << "World"; ,'
# Hello
# World
```

# ルートノード

ルートノードではファイル全体や括弧の直下など、どんな式でも書ける場所のルールを定義します。

## 複文 `runner; ...; getter`

複文は、0個以上の文と複文自体の値となる末尾式を `;` で区切って繋いだものです。

以下のサンプルコードにおいて、最後の `a` の行のみが式（getter）扱いで、その上の3行は文（runner）扱いです。

以下のサンプルコードでは、変数 `a` を宣言しつつ10を代入し、10が格納されている `a` の値を出力、次に `a` に20を代入し、末尾式として20の格納されている `a` を指定しています。

```shell
$ flc '
  a := 10;
  OUT(a);
  a = 20;
  a
'
# 10
# 20
```

---

末尾式は省略することができます。

その場合、文が末尾式でないことを示すために、末尾に `;` が必要となる場合があります。

末尾式が省略された複文の値は常に `NULL` となります。

```shell
$ flc '1 + 2;'
# NULL

$ flc ''
# NULL
```

---

複文内での `;` の記述は、末尾を除いて柔軟です。

項の前や中間に `;` を余計に多く書いても問題ありません。

末尾式の後にはセミコロンを書くことはできません。

また、改行は `;` の代わりになります。

```shell
$ flc '
  a := 10
  OUT(a)
  ; ; ; a = 20; ; ;
  a
'
# 10
# 20
```
